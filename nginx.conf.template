
worker_processes  auto;
worker_rlimit_nofile 100000;
daemon off;
error_log stderr info;

events {
    worker_connections  90000;
    multi_accept on;
}


http {
    access_log /dev/stdout;

    nchan_message_timeout 1h;
    # Prevent closing channels too fast
    nchan_channel_timeout 1h;

    nchan_shared_memory_size 1G;

    # Only store 1 message at a time
    nchan_message_buffer_length 1;

    # define publisher and subscriber endpoints in your server context
    upstream my_redis_server {
        nchan_redis_server "${REDIS_SERVER}";
    }
    server { 
        listen 80 backlog=1024 reuseport;
     
        location / {
            return 204;
        }

        location /nchan_stub_status {
            nchan_stub_status;
        }

        location /pub {
            # authenticate request
            auth_request /auth;

            # activate publisher mode for this location
            nchan_publisher;

            # query string based channel id
            nchan_channel_id $arg_id;

            # cors headers
            nchan_access_control_allow_origin '*';

            # redis DB
            nchan_redis_pass my_redis_server;
        }

        location ~ /sub/(.*) {
            keepalive_requests 10000;

            # activate event source mode for this location (and websocket as a backup)
            nchan_subscriber eventsource websocket;
            #add_header Content-Type "text/event-stream" always;

            # positional channel path
            nchan_channel_id $1;

            # Don't allow subscribing to non-existing channels
            nchan_subscribe_existing_channels_only on;

            # Send last message when subscribing
            nchan_subscriber_first_message 1;
            # redis DB
            nchan_redis_pass my_redis_server;
        }

        location /auth {
            if ($http_authorization = "${PUBSUB_SECRET}") {
                return 200;
            }
            return 401;
        }

    }
}

