
worker_processes  auto;
worker_rlimit_nofile 100000;
daemon off;
error_log stderr info;

events {
    worker_connections  90000;
    multi_accept on;
}


http {
    access_log /dev/stdout;

    nchan_message_timeout 1h;
    # Prevent closing channels too fast
    nchan_channel_timeout 1h;

    nchan_shared_memory_size 700M;

    # Only store 1 message at a time
    nchan_message_buffer_length 1;

    # define publisher and subscriber endpoints in your server context
    server { 
        listen 80 backlog=1024 reuseport;

        # Backward compatibility with old modulle
        rewrite ^/sub/(.*).b([0-9]*) http://$host/sub/$1 permanent;
     
        location / {
            return 204;
        }


        location /pub {
            # authenticate request
            auth_request /auth;

            # activate publisher mode for this location
            nchan_publisher;

            # query string based channel id
            nchan_channel_id $arg_id;

            # cors headers
            nchan_access_control_allow_origin *;
        }

        location ~ /sub/(.*) {
            keepalive_requests 10000;
            # activate event source mode for this location (and websocket as a backup)
            nchan_subscriber eventsource websocket;
            #add_header Content-Type "text/event-stream" always;
            nchan_access_control_allow_origin *;
            # positional channel path (and group, for stats)
            nchan_channel_id $1;

            # Don't allow subscribing to non-existing channels
            nchan_subscribe_existing_channels_only on;

            # Send last message when subscribing
            nchan_subscriber_first_message 1;
        }

        location /auth {
            if ($http_authorization = "${PUBSUB_SECRET}") {
                return 200;
            }
            return 401;
        }

    }
}
